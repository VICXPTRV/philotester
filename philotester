#!/bin/bash

source config
source utils/measure_delay.sh
source utils/check_integers.sh
source utils/style.sh
source utils/printers.sh
source utils/build_and_norm.sh
source utils/validate_output.sh

# PATH
EXEC="${EXEC_PATH}/philo"
CASES_PATH="cases/"
if [[ ! -d "logs" ]]; then
	mkdir logs
else
	rm -f logs/*
fi
LOGS_PATH="logs"

# VALGRIND
VALG_PATH="valgrind"
[[ ! -d "${VALG_PATH}" ]] && mkdir ${VALG_PATH}
[[ ! -f "${VALG_PATH}/valgrind.log" ]] && touch ${VALG_PATH}/valgrind.log
[[ ! -f "${VALG_PATH}/valgrind.supp" ]] && touch "${VALG_PATH}/valgrind.supp"
VALG_LOG=${VALG_PATH}/valgrind.log
VALG_SUP=${VALG_PATH}/valgrind.supp
VALGRIND="valgrind $VALGRIND_FLAGS --log-file=$VALG_LOG"
> "$VALG_LOG"

# FLAGS
flag_valgrind=false
while getopts "v" flag; do
	case $flag in
		v) flag_valgrind=true ;;
	esac
done
shift $((OPTIND - 1))

# CASES
if [[ $# -gt 0 ]]; then
	cases=("$@")
else
	cases=($(ls $CASES_PATH)); fi

# GLOBALS
TOTAL=0
FAILED=0
EXEC_MSG=""
TEST_MSG=""
FAIL_FLAG=false
declare -gA table

fill_table() {
	time="$1"
	philo="$2"
	action="$3"
	max="$4"

	declare -gA table

	# Initialize if not set
	[[ -z "${table[$philo]}" ]] && table["$philo"]=""

	if ! [[ "$philo" =~ ^[0-9]+$ ]]; then
		TEST_MSG="Invalid philosopher number: $philo (not a number)"
		FAIL_FLAG=true
    	return
	fi
	if [[ "$philo" -lt 1 || "$philo" -gt "$max" ]]; then
		TEST_MSG="Invalid philosopher number: $philo max: $max"
		FAIL_FLAG=true
        return
    fi
    table["$philo"]+="$time $action\n"
}

validate_test() {
	output="$1"
    log_file="$2"
	test_case="$3"

	# Log the output
	echo -e "${output}" > "$log_file"

	# Get program input
	number_of_philos=$(echo "$test_case" | cut -d " " -f 1)
	t_die="$(echo "$test_case" | cut -d " " -f 2)"
	t_eat="$(echo "$test_case" | cut -d " " -f 3)"
	t_sleep="$(echo "$test_case" | cut -d " " -f 4)"
	meals_to_eat="$(echo "$test_case" | cut -d " " -f 5)"
	extra_arg="$(echo "$test_case" | cut -d " " -f 6)"

	# Check for invalid input and stop further processing
	if is_invalid_input "$number_of_philos" "$t_die" "$t_eat" "$t_sleep" "$meals_to_eat" "$extra_arg"; then
		print_result
		return
	fi

	# Parse output
	while IFS=" " read -r first second rest; do
		TEST_MSG=""
		if echo "$first $second $rest" | grep -q "segmentation"; then
			TEST_MSG="Segmentation fault"
			continue
		elif [[ "$first" =~ ^[0-9]+$ && "$second" =~ ^[0-9]+$ ]]; then
			time="$first"
			philo="$second"
			action="$rest"
			fill_table "$time" "$philo" "$action" "$number_of_philos"
		else
			TEST_MSG="Unexpected output"
			FAIL_FLAG=true
			continue
    	fi
	done < "$log_file"

	# Handle output
	validate_output "$number_of_philos" "$t_die" "$t_eat" "$t_sleep" "$meals_to_eat" 
	print_result
	return
}

run_tests() {
    case="$1"
    test_file="${CASES_PATH}/${case}"
    test_number=1

	# Run each test in current case file
    while IFS= read -r test_case || [[ -n "$test_case" ]]; do
        [[ -z "$test_case" ]] && continue

        log_file="${LOGS_PATH}/${case}_${test_number}.log"
		LEAK_RES=""

		# !RUN PROGRAMM!
        if $flag_valgrind; then
			output=$(timeout $T_LIMIT $VALGRIND $EXEC $test_case 2>&1)
			status=$?
			if [[ $status -eq 124 ]]; then
				TEST_MSG="Timeout"; fi
			if grep -q "definitely lost:" "$VALG_LOG"; then
				LEAK_RES=$LEAK; fi
        else
            output=$(timeout $T_LIMIT $EXEC $test_case 2>&1); fi
			status=$?
			if [[ $status -eq 124 ]]; then
				TEST_MSG="Timeout"; fi

		validate_test "$output" "$log_file" "$test_case"

		unset table
        ((TOTAL++))
		((test_number++))
    done < "$test_file"
}

# RUN
run_cases() {
	# loop through case files
	for case in ${cases[@]}; do
		echo -e "${HEADER_EMOJI}${HEADER_COLOR} Testing: ${case}${RESET}"
		if [[ ! -f "${CASES_PATH}/$case" ]]; then
			echo -e "${KO_COLOR}$ Test file not found: ${case}${RESET}"
			return
		fi
		run_tests "${case}"
		echo -e "\n"
	done
}

# RUN SCRIPT
print_header
# measure_system_delay
check_norm
build_program
run_cases
print_footer
